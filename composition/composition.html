<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>作业问题反馈系统－开发杂谈</title>
  <link rel="stylesheet" href="bootstrap.min.css">
  <link rel="stylesheet" href="composition.css">
  <link rel="stylesheet" href="google-code-prettify/prettify.css">
</head>
<body>
<div class="container">
  <h1 class="text-center">
    <del>如何成为一个疯掉的全栈工程师<br/></del>
    作业问题反馈系统－开发杂谈
    <small><br/>CUBE Workshop</small>
  </h1>
  <nav class="catalogue">
    <h2 class="text-center">目录</h2>
    <ol>
      <li><a>
        <del>发生在某个老师身上的惨剧</del>
        &nbsp;需求的产生和分析</a></li>
      <li><a>
        <del>抓壮丁</del>
        &nbsp;团队的组织</a></li>
      <li><a>
        <del>脑补</del>
        &nbsp;整体设计</a></li>
      <li><a>
        <del>推卸责任</del>
        &nbsp;素材的分解和职责的分配</a></li>
      <li><a>
        <del>Python大法好</del>
        &nbsp;开发语言的选择</a></li>
      <li><a>&nbsp;开发框架的选择</a></li>
      <li><a>
        <del>疯狂盗版软件(有钱了保证还上)</del>
        &nbsp;开发工具的选择</a></li>
      <li><a>
        <del>混乱的</del>
        &nbsp;初次迭代</a></li>
      <li><a>
        <del>又TM改需求!</del>
        &nbsp;初次交付</a></li>
      <li><a>
        <del>实际上因为初次进度太快所以没人干活的</del>
        &nbsp;二次迭代</a></li>
      <li><a>
        <del>并不存在的</del>
        &nbsp;二次交付</a></li>
      <li><a>
        <del>赶工期（deadline的威胁）!</del>
        &nbsp;第三次迭代</a></li>
      <li><a>
        <del>终于（好心人捐个服务器呗）</del>
        &nbsp;最终产品的发布</a></li>
      <li><a>
        <del>根本不会有人干的</del>
        &nbsp;后期维护</a></li>
      <li><a href="#spe-01">
        <del>死亡卡顿的故事</del>
        &nbsp;特别篇01-自制表单验证器始末</a></li>
      <li><a>
        <del>一团乱麻的HTML，我再也不想看到了！</del>
        &nbsp;特别篇02-重构</a>
      </li>
      <li><a>
        <del>现在我有两个问题了</del>
        &nbsp;特别篇03-正则表达式</a>
      </li>
      <li><a>
        <del>我或许是个还算可以的程序员，但我一定是个糟糕的管理者!</del>
        &nbsp;感想</a></li>
      <li>
        <del>
          <a>关于这次开发，一些你不知道的秘密</a>
        </del>
      </li>
    </ol>
  </nav>
  <div id="spe-01">
    <h2 class="text-center">特别篇01-自制表单验证器始末</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;在开发很多web app时，在包括登录和注册页面等的一系列页面中都能见到form表单的运用，
      同时，对表单有效性的检查也成为了一个让人
      <del>抓狂</del>
      不能不仔细考虑的问题。
    </p>
    <p>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;实际上最容易实现的方式就是前端完全不考虑表单的有效性，只是将整个表单序列化之后将其全部
      <del>甩锅</del>
      发送给后端，并让后端负责有效性检查，再通过重定向到错误提示页面来实现。
    </p>
    <p>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;但是我并不认为这是个好的方法，原因有以下几点：
    </p>
    <ol>
      <li>用户体验差（填错一个数据就需要重填整个表单）。</li>
      <li>难以（虽然并非不可能）向用户反馈到底是哪几个数据填写出现了问题。</li>
      <li>使用错误提示页面显得很不优雅，而且需要额外设计错误提示页面。</li>
      <li>难以
        <del>装逼</del>
        体现出我们的技术水平。
      </li>
    </ol>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 所以我们决定使用Ajax的方式验证表单，具体来说就是每次表单中的某个数据更改，就将数据发送到后端来进行验证。
    </p>
    <p>本着不重复造轮子
      <del>偷懒</del>
      的原则，我们首先在网上搜索了一些现成的表单验证器，但我们发现这些验证器：
    </p>
    <ol>
      <li>使用复杂</li>
      <li>文件大，浪费用户带宽</li>
      <li>无法自定义错误提示的显示位置</li>
      <li>部分验证器是收费的，要价还不低
        <del>现在来钱这么容易？这都tmd能卖钱？</del>
      </li>
    </ol>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;所以我们
      <del>头脑一热就</del>
      决定自己开发一款专用表单验证器
      <del>，我到现在都后悔做出这个决定</del>
      。
    </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;首先我们明确了需求：我们需要一段程序，它可以：</p>
    <ol>
      <li>在用户输入时动态地进行验证用户正在修改的域</li>
      <li>在验证发现这一域无效时，（在自定义位置）显示错误消息，反正显示正确消息</li>
      <li>在任何一个域无效或为空时，禁用提交按钮</li>
    </ol>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;一开始，我们试图在原有的JS代码中添加表单验证逻辑，但是这让代码中多出了大量的重复代码，我们很快意识到单独做一个表单验证库是有必要的。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;在对原有代码进行了一些重构后，我们成功地剥离了表单验证逻辑，并且得到了下面的代码</p>
    <pre class="prettyprint">
      <code>
/**
 * 单个field验证器
 * @param csrf_token 发送给服务器的csrf token
 * @param object_to_validate 要验证的对象（jQuery对象）
 * @param validated_called_func 验证完成后调用的函数
 * @param url_to_send_value_to ajax验证地址
 * @param other_object_to_send_with 要一同发送的其他对象
 * @param user_validate_func 用户自定义验证函数（优先级高于ajax验证）
 */
function Validator(csrf_token, object_to_validate, validated_called_func, url_to_send_value_to, other_object_to_send_with, user_validate_func) {
    this.object_wrapped = object_to_validate;
    this.url_to_send = url_to_send_value_to;
    this.data_objects = other_object_to_send_with;
    this.func = user_validate_func;
    this.validated = validated_called_func;
    this.validate = function () {
        var to_post = [
            {name: "csrfmiddlewaretoken", value: csrf_token},
            {name: this.object_wrapped.attr("name"), value: this.object_wrapped.val()}
        ];
        if (this.data_objects != null) {
            for (var i = 0; i < this.data_objects.length; ++i) {
                var data_obj = this.data_objects[i];
                to_post[to_post.length] = {name: data_obj.attr("name"), value: data_obj.val()};
            }
        }
        if (this.func != null && !this.func()) {
            if (this.validated != null) {
                this.validated(false);
            }
            return false;
        }
        var is_success = false;
        $.post(this.url_to_send, to_post, function (ret) {
            is_success = ret.is_valid;
        });
        if (this.validated != null) {
            this.validated(is_success);
        }
        return is_success;
    }
}
/**
 * field组验证器
 * @param all_validators 包含的子field验证器
 * @note 在外部调用validate来验证子field
 * @note 在外部调用isAllValid来检验是否整个组都通过了验证，可以用来判断是否允许表单提交
 */
function ValidatorGroup(all_validators) {
    this.validators = all_validators;
    this.is_valid_last_time = [];
    for (var i = 0; i < this.validators.length; ++i) {
        this.is_valid_last_time[i] = false;
    }
    this.validate = function (which_to_validate) {
        if (which_to_validate == null) {
            for (var i = 0; i < this.validators.length; ++i) {
                this.is_valid_last_time[i] = this.validators[i].validate();
            }
        } else {
            this.is_valid_last_time[which_to_validate] = this.validators[which_to_validate].validate();
        }
    };
    this.isAllValid = function () {
        return this.is_valid_last_time.every(function (ele) {
            return ele;
        });
    }
}</code>
    </pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;开始我们发现这段代码并不正常工作——没有一个验证能通过，因为ajax默认是异步的（正如其名所示【第一个a代表async，异步】），在服务器能够返回数据之前，validate函数已经返回false了。
      当然有一个quick and dirty的解决方案：强制使用同步ajax，实现这点十分简单，在ajaxSetup中将async的值设置为false即可。
    </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;然而我们的直觉告诉我们这可能并不是个好主意
      <del>我刚写的时候就TM料到了，可我TM就是懒得改。</del>
      。果然，在很慢的网速下测试的时候，这样做的缺陷暴露无遗：每敲击一下按键就需要等待很久，等浏览器获取到服务器的验证结果后才能继续操作。
    </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;这样的产品显然不可能令人满意！虽然现在网速普遍可以在可接受的时间内完成这种数据交换，但是仍存在一些区域
      <del>例如我家、和宝图</del>
      网络条件不佳。我们相信一个异步的表单验证器是有必要的。
    </p>
  </div>
</div>
<script src="google-code-prettify/prettify.js"></script>
<script src="jQuery.js"></script>
<script>
  $(function () {
    PR.prettyPrint();
  });
</script>
</body>
</html>